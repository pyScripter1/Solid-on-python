# Принципы проектирования SOLID с примерами на Python

Эффективный алгоритм – основа работы эффективного программного обеспечения. Когда алгоритм уже есть, следующая задача – сделать так, чтобы ПО было разработано с использованием лучших методов проектирования и лучшей архитектуры. Специалисты, исследователи и эксперты определили лучшие практики эффективного проектирования программных приложений. Одной из наиболее популярных среди них являются принципы проектирования, известные под аббревиатурой SOLID.

Самыми известными и важными считаются принципы проектирования, предложенные Робертом К. Мартином (также известным как Дядя Боб). Дядя Боб представил много разных принципов проектирования, однако самых популярных всего 5, сокращенно их называют SOLID-принципами. В основном они сфокусированы вокруг объектно-ориентированной парадигмы проектирования ПО. Если учитывать эти рекомендации при разработке объектно-ориентированного ПО, код станет не таким сложным, снизится риск поломок, улучшится взаимодействие между различными объектами и код станет более гибким, читаемым и управляемым. 

SOLID-принципы Дяди Боба расшифровываются следующим образом:

* S – Принцип единственной ответственности (Single Responsibility Principle),
* O – Принцип открытости/закрытости (Open‐Closed Principle),
* L – Принцип подстановки Барбары Лисков (Liskov Substitution Principle),
* I – Принцип разделения интерфейсов (Interface Segregation Principle),
* D – Принцип инверсии зависимостей (Dependency Inversion Principle).

В этом репозитории я поделюсь своим пониманием принципов проектирования SOLID Роберта К. Мартина и снабжу его примерами на Python.

Примечание: Примеры кода, которые я привожу, будут весьма минималистичны по своей природе, поскольку они написаны с единственной целью – объяснить соответствующий принцип. Они могут быть неполными или не соответствовать какому-либо другому принципу или передовой практике. Я прошу читателей принять это во внимание при чтении кода каждого принципа.

## Принцип единственной ответственности S
Принцип единой ответственности гласит, что у каждого класса должна быть только одна «ответственность» и он не должен брать на себя другие обязанности. Роберт К. Мартин объяснял его так: «У класса должна быть лишь одна причина для изменения». 

Давайте в качестве примера возьмем приложение телефонного справочника. Мы будем делать телефонный справочник, в котором будет класс TelephoneDirectory. Он будет «нести ответственность» за ведение записей справочника, то есть телефонных номеров и названий организаций, которым принадлежат номера. Ожидается, что класс будет выполнять следующие операции: добавлять новую запись (Name и Telephone Number), удалять существующую запись, изменять номер телефона, присвоенный сущности Name, и предоставлять поиск, который будет возвращать номер, присвоенный сущности Name.
Пример использования принципа единственной ответственности здесь: [Клик](https://github.com/pyScripter1/Solid-on-python/tree/main/Single_Responsibility_Principle)


## Принцип окрытости/закрытости O
Принцип открытости/закрытости впервые был сформулирован Бернардом Мейером в 1988 году. Роберт К. Мартин говорил о нем так «Наиболее важный принцип открытости/закрытости гласит «Сущности программы (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменений». Классы должны быть открыты для расширения, но закрыты для модификации

Следование этому принципу гарантирует, что класс определен достаточно, чтобы делать то, что он должен делать. Добавление любых дополнительных функций может быть реализовано путем создания новых сущностей, которые расширяют возможности существующего класса и добавляют дополнительные функции самим себе. Таким образом можно предотвратить частые и тривиальные изменения в хорошо зарекомендовавшем себя классе низкого уровня. 
Пример использования принципа открытости/закрытости здесь: [Клик](https://github.com/pyScripter1/Solid-on-python/tree/main/Open_Closed_Principle)


## Принцип подстановки Барбары Лисков L
Принцип подстановки Лисков был одним из самых сложных принципов для меня, и чтобы понять его правильно, мне пришлось посмотреть различные примеры в Интернете. Я считаю, что после осознания, этот принцип станет одним из самых простых, среди принципов, которых следует придерживаться при разработке объектно-ориентированных приложений. Объекты должны быть заменяемыми экземплярами своих подтипов без изменения правильности программы

Принцип подстановки Лисков гласит: «Объекты в программе должны быть заменяемы экземплярами их подтипов без ущерба корректности работы программы».

Принцип подстановки Лисков был предложен Барбарой Лисков. Он предполагает отношение подтипов, называемое сильным поведенческим подтипом. Этот принцип говорит нам о том, что если класс Sub является подтипом класса Sup, тогда в программе объекты типа Sup должны легко заменяться объектами типа Sub без необходимости изменения кода. Дядя Боб включил этот принцип в число 5 лучших принципов проектирования SOLID.
Пример использования принципа подстановки Барбары Лисков здесь: [Клик](https://github.com/pyScripter1/Solid-on-python/tree/main/Liskov_Substitution_Principle)


## Принцип разделения интерфейсов I
Принцип разделения интерфейсов гласит, что «Ни один клиент не должен зависеть от методов, которые он не использует». Клиенты не должны зависеть от методов, которые они не используют

Принцип разделения интерфейсов был предложен Робертом К. Мартином, когда он консультировал компанию Xerox.

Принцип разделения интерфейсов предполагает создание небольших интерфейсов, известных как «ролевые интерфейсы», вместо большого интерфейса, состоящего из нескольких методов. Разделяя методы по ролям на более мелкие интерфейсы, клиенты будут зависеть только от методов, которые имеют к ним отношение.

Допустим, мы разрабатываем приложение для различных коммуникационных устройств. Мы говорим, что устройство связи – это устройство, которое будет иметь одну или несколько из следующих функций: совершать звонки, отправлять SMS или искать в Интернете. Итак, мы создаем интерфейс с именем CommunicationDevice и добавляем соответствующие абстрактные методы для каждой из этих функций, чтобы любой создаваемый класс смог реализовать эти методы.

Затем мы создаем класс SmartPhone с помощью интерфейса CommunicationDevice и реализуем функционал абстрактных методов. До сих пор все было в порядке.

Теперь предположим, что нам нужно создать стационарный телефон. Он тоже является устройством связи, поэтому мы создаем новый класс LandlinePhone через тот же интерфейс CommunicationDevice. Именно здесь мы сталкиваемся с проблемой из-за объемного интерфейса CommunicationDevice. В классе LandlinePhone мы реализовываем метод make_calls(), но поскольку мы также наследуем абстрактные методы send_sms() и browse_internet(), мы должны предоставить реализацию и этих двух абстрактных методов в классе LandlinePhone, даже если они в принципе неприменимы к этому виду телефонов. Мы можем либо создать исключение, либо оставить pass вместо реализации, но нам все равно нужно ее предоставить.
Примеры использования принципа разделения интерфейсов здесь: [Клик](https://github.com/pyScripter1/Solid-on-python/tree/main/Interface_Segregation_Principle)


## Принцип инверсии зависимостей D
Принцип инверсии зависимостей гласит: Зависимости должны строиться на абстракциях, а не на конкретных реализациях

* Модуль высокого уровня не должен зависеть от модулей низкого уровня. И то, и другое должно зависеть от абстракций. 
* Абстракции не должны зависеть от деталей реализации. Детали реализации должны зависеть от абстракций.

Если ваш код уже реализует принципы открытости/закрытости и подстановки Лисков, он уже будет неявно согласован с принципом инверсии зависимостей.  
Следуя принципу открытости/закрытости, вы создаете интерфейсы, которые можно использовать для предоставления различных высокоуровневых реализаций. Следуя принципу подстановки Лисков, вы гарантируете, что сможете заменить экземпляры класса низкого уровня объектами класса высокого уровня без какого-либо негативного воздействия на приложение. Таким образом, следуя этим двум принципам, вы гарантируете, что ваши классы высокого уровня и классы низкого уровня зависят от интерфейсов. Следовательно, вы неявно следуете принципу инверсии зависимостей.
