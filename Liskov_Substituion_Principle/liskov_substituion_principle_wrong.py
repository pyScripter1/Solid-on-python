"""
Допустим, у нас есть базовый класс Car,
который отвечает за тип автомобиля. Класс Car наследуется подклассом PetrolCar.
Аналогично, базовый класс Car может быть унаследован другими классами, которые могут расширять его возможности.

Как мы видим здесь, стандартной спецификации для добавления свойств Car не существует,
и разработчикам остается реализовать ее удобным для них способом.
Один разработчик может реализовать ее как словарь, а другой как кортеж. Таким образом,
она может быть реализована несколькими способами.

Пока проблем нет. Но давайте предположим, что есть задача найти все автомобили красного цвета.
Давайте попробуем написать функцию, которая брала бы все автомобили и пыталась найти все
красные путем реализации объекта суперкласса Car.

Как видно из кода, мы пытаемся просмотреть список объектов Car. Именно здесь мы нарушаем принцип подстановки Лисков,
поскольку мы не можем заменить объекты супертипа
Car объектами подтипа PetrolCar внутри функции поиска красных автомобилей.
"""



class Car:
  def __init__(self, type):
    self.type = type

class PetrolCar(Car):
  def __init__(self, type):
    self.type = type

car = Car("SUV")
car.properties = {"Color": "Red", "Gear": "Auto", "Capacity": 6}

petrol_car = PetrolCar("Sedan")
petrol_car.properties = ("Blue", "Manual", 4)

cars = [car, petrol_car]

def find_red_cars(cars):
  red_cars = 0
  for car in cars:
    if car.properties['Color'] == "Red":
      red_cars += 1
  print(f'Number of Red Cars = {red_cars}')

find_red_cars(cars)